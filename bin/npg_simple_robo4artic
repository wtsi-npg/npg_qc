#!/usr/bin/env perl

use strict;
use warnings;
use FindBin qw($Bin $Script);
use lib ( -d "$Bin/../lib/perl5" ? "$Bin/../lib/perl5" : "$Bin/../lib" );
use Log::Log4perl qw(:levels);
use Try::Tiny;
use Text::CSV;
use Carp;
use Readonly;

use npg_tracking::glossary::rpt;
use npg_tracking::glossary::composition::factory::rpt_list;
use npg_tracking::glossary::moniker;
use npg_qc::autoqc::checks::review;

our $VERSION = '0';

Readonly::Scalar my $NEG_CONTROL_NUM_READS_THRESHOLD => 100;

Readonly::Scalar my $NEG_CONTROL_REGEXP => qr/\A CGAP- | Negative[ ]control | blank /ismx;
Readonly::Scalar my $POS_CONTROL_REGEXP => qr/\A Positive[ ]control /ismx;
Readonly::Scalar my $HERON_REGEXP       => qr/\A [[:upper:]]{4}- /smx;
Readonly::Scalar my $NEG_CONTROL_FLAG   => q[NEG_CONTROL];
Readonly::Scalar my $POS_CONTROL_FLAG   => q[POS_CONTROL];
Readonly::Scalar my $HERON_FLAG         => q[HERON];
Readonly::Scalar my $UNKNOWN_FLAG       => q[UNKNOWN];

# Order of rules evaluation is important, hence a list.
Readonly::Array  my @SAMPLE_ASSIGNMENT_RULES => (
                               [$POS_CONTROL_REGEXP, $POS_CONTROL_FLAG],
                               [$NEG_CONTROL_REGEXP, $NEG_CONTROL_FLAG],
                               [$HERON_REGEXP, $HERON_FLAG],
                                                );

Readonly::Scalar my $ARTIC_NF_REPO_NAME =>  q[ncov2019-artic-nf];
Readonly::Scalar my $ARTIC_QC_PASS      =>  q[TRUE];
Readonly::Scalar my $ARTIC_QC_FAIL      =>  q[FALSE];
Readonly::Scalar my $ARTIC_SUMMARY_KEY  => qq[$ARTIC_NF_REPO_NAME QC summary];

Readonly::Scalar my $QC_TYPE            => q[mqc];

Log::Log4perl->easy_init({layout => '%d %-5p %c - %m%n',
                          level  => $INFO});
my $logger = Log::Log4perl->get_logger();

my $dir_out = $ARGV[0];
if (defined $dir_out) {
  if (($dir_out ne q[]) and (-d $dir_out) and (-w $dir_out)) {
    $logger->info("Using output directory $dir_out");
  } else {
    $logger->error(
      "Output directory $dir_out does not exists or is not writable");
    exit 2;
  }
} else {
  $logger->info('Using current directory as an output directory');
}

my $line_number = 0;
my $csv = Text::CSV->new();

while (my $line = $line_number ? $csv->getline_hr(*STDIN) : $csv->getline(*STDIN)) {
  $line_number++;

  # Register the first header. After this $line is going to be a hash.
  if ($line_number == 1) {
    $csv->column_names($line);
    next;
  }

  my $file_name_root = $line->{'sample_name'};
  if ($file_name_root && ($file_name_root eq 'sample_name')) {
    next; # this was header repeat
  }

  my $l = "Line $line_number:";
  my $outcome;
  my $num_reads;
  my $r;
  my $sname;
  my $lib_type;

  try {
    $file_name_root or croak 'no file name in sample_name column';

    $outcome = $line->{'qc_pass'};
    defined $outcome or croak 'no outcome in qc_pass column';
    $outcome =~ s/\s+\Z//xms;
    $outcome =~ /\A($ARTIC_QC_PASS | $ARTIC_QC_FAIL)\Z/xms or croak
      "unexpected outcome value '$outcome'";

    $num_reads = $line->{'num_aligned_reads'};
    defined $num_reads or croak "num_aligned_reads is not defined for $file_name_root";
    ($num_reads >= 0) or croak "num_aligned_reads is negative for $file_name_root";

    my $h = npg_tracking::glossary::moniker->parse_file_name($file_name_root);
    my $rpt = npg_tracking::glossary::rpt->deflate_rpt($h);
    $r = npg_qc::autoqc::checks::review->new(rpt_list => $rpt);

    $sname = $r->lims->sample_supplier_name();
    if (!$sname) {
      # Not exiting here, the supplier name is often not set for R&D samples.
      # Beware of the sourse of LIMS data, the supplier name is not set
      # in XML feeds. Use a samplesheet!
      $sname = q[];
      $logger->error("Sample supplier name is not set for $file_name_root");
    }
    $lib_type = $r->lims->library_type();
    $lib_type or croak "library type is not set for $file_name_root";

  } catch {
    $logger->error("$l $_");
    exit 1;
  };

  my $flag = $UNKNOWN_FLAG;
  foreach my $rule (@SAMPLE_ASSIGNMENT_RULES) {
    if ($sname =~ $rule->[0]) {
      $flag = $rule->[1];
      last;
    }
  }

  if ($flag eq $UNKNOWN_FLAG) {
    $logger->warn(
      "$l $file_name_root, sample '${sname}' - attribution failed");
  } elsif ($flag eq $POS_CONTROL_FLAG) {
    $logger->warn(
      "$l $file_name_root, sample '${sname}' - positive control, skipping");
    next;
  }

  my $condition =
    qq[Negative control, number of primer-trimmed aligned reads is less than $NEG_CONTROL_NUM_READS_THRESHOLD];
  if ($flag eq $HERON_FLAG) {
    $condition = qq[Passed $ARTIC_NF_REPO_NAME QC];
  }

  my $pass = (($flag eq $HERON_FLAG) or ($flag eq $UNKNOWN_FLAG))
             ? ($outcome eq $ARTIC_QC_PASS ? 1 : 0)
             : ($num_reads < $NEG_CONTROL_NUM_READS_THRESHOLD ? 1 : 0);
  $r->result->pass($pass);

  $r->result->qc_outcome($r->generate_qc_outcome($QC_TYPE));
  $r->result->library_type($lib_type);
  $r->result->evaluation_results({$condition => $r->result->pass});
  $r->result->criteria({'and' => [$condition]});

  $r->result->set_info($ARTIC_SUMMARY_KEY, $line);  # Capture the QC summary,
  $r->result->set_info('Script_name', $Script);     # this script name
  $r->result->set_info('Script_version', $VERSION); # and version

  try {
    $r->result->store($dir_out);
  } catch {
    $logger->error("$l $_");
    exit 2;
  };
}

if ($line_number == 0) {

  # All QC summary files are empty, we do not know how many files
  # in total were fed into the script and whether the files contained
  # summaries for one or many samples.

  # Do we want to deal with this case in this script or create a
  # a different script for a single file single sample scenario
  # only?  We would need the rpt key to figure out the entity. Then
  # we can access the deplexing metrics and, in case of confirmed
  # zero reads, assign a fail to a heron sample and a positive
  # control and a pass to a negative control. Or error if not zero
  # reads.

  $logger->warn(q[Input is empty]);
}

exit 0;

__END__

=head1 NAME

npg_simple_robo4artic

=head1 USAGE

=head1 CONFIGURATION

=head1 SYNOPSIS

  echo artic_summary.qc.csv  | npg_simple_robo4artic
  echo artic_summary.qc.csv | npg_simple_robo4artic 'my_dir'

=head1 DESCRIPTION

This script creates autoqc review result JSON files for
entities and outcomes piped from STDIN. One line of input
produces one file, unless this input is considered irrelevant.

The JSON files are created in the working directory unless an
alternative directory is specified as teh only argument. The
qc outcomes are recorded as preliminary manual QC outcomes.

The actic QC summary is recorded under the
'ncov2019-artic-nf QC summary' key in the info attribute of
the result. The summary is recorded as a hash with keys as
column headers and values as corresponding column values for
a particular sample. 

Example of input:

  sample_name,pct_N_bases,pct_covered_bases,longest_no_N_run,num_aligned_reads,fasta,bam,qc_pass
  34032_2#25,0.99,98.52,19221,4603415,34032_2#25.primertrimmed.consensus.fa,34032_2#25.mapped.primertrimmed.sorted.bam,TRUE
  34014_1#105,87.85,9.91,376,415,34014_1#105.primertrimmed.consensus.fa,34014_1#105.mapped.primertrimmed.sorted.bam,FALSE

=head1 REQUIRED ARGUMENTS

None

=head1 OPTIONS

=head1 SUBROUTINES/METHODS

=head1 DIAGNOSTICS

=head1 CONFIGURATION AND ENVIRONMENT

=head1 DEPENDENCIES

=over

=item strict

=item warnings

=item FindBin

=item lib

=item Carp

=item Try::Tiny

=item Log::Log4perl

=item Text::CSV

=item Readonly

=item  npg_tracking::glossary::rpt

=item npg_tracking::glossary::composition::factory::rpt_list

=item npg_tracking::glossary::moniker

=item npg_qc::autoqc::checks::review

=back

=head1 INCOMPATIBILITIES

=head1 EXIT STATUS

=head1 BUGS AND LIMITATIONS

=head1 AUTHOR

Marina Gourtovaia

=head1 LICENSE AND COPYRIGHT

Copyright (C) 2020 Genome Research Ltd.

This file is part of NPG.

NPG is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
