#!/usr/bin/env perl

# Author:        Irina Abnizova & Steven Leonard
# Created:       2021-04-12
#
# script which reads a substitution report generated by bambi substitution_analysis and generates some metrics
# 
# Flags:
#  -h : help
#  -v : verbose
#  -o <output_file> : [OPTIONAL] Specify output file name (default is metrics.txt)
#

use strict;
use warnings;
use FindBin qw($Bin);
use lib ( -d "$Bin/../lib/perl5" ? "$Bin/../lib/perl5" : "$Bin/../lib" );

use Getopt::Long;

use File::Slurp;
use FileHandle;
use Math::Round;
use Statistics::Lite qw(:all);

##no critic
our $VERSION = '0';

main();
0;

sub main {
  my $opts = get_options();

  my $err_file = shift(@ARGV);

  my $tags = [qw(SET RCH RCL PRCNH PRCNL)];

  my $err_data = read_err_file($err_file, $tags);

  if ($opts->{'verbose'}) {
    printf("maximal quality $err_data->{maQ}\n") if exists($err_data->{maQ});
    printf("number of cycles $err_data->{ncyc}\n") if exists($err_data->{ncyc});
    if (exists($err_data->{rch})) {
      my %coH1 = %{$err_data->{rch}->{1}->{-1}};
      printf("counts of HQ substitutions R1");
      foreach (sort keys %coH1) {
        print "\t$_:$coH1{$_}";
      }
      print "\n";
    }
  }

  my $metrics = metrics_gen_assym_prediction($err_data, $opts->{verbose});

  if ($opts->{'verbose'}) {
    printf("GT_meTi $metrics->{GT_meTi}\n");
    printf("likelihood of C2A $metrics->{likelihood}\n");
  }

  write_metrics_file( $metrics, $opts->{output});

  return;
}

# process command line options
sub get_options() {

  my $usage = qq[

  Usage:
    
         npg_substitution_metrics.pl <opts> file

  Options:

         -o <file>     output file, default metrics.txt
         -v            verbose
         -h            help

  ];

  my %options = (verbose => 0, output => 'metrics.txt');

  my $result = GetOptions(\%options,
                          "output:s",
                          "verbose",
                          "help"
                          );

  die("$usage\n") if( !$result || $options{help} || scalar(@ARGV) < 1);

  return \%options;
}

# read error file
sub read_err_file () {
  my ($file, $tags) = @_;

  my @lines = read_file($file);
  die "No data in $file\n" unless @lines;

  my %err_data = ();

  foreach my $tag (@{$tags}) {
    if ( $tag eq 'SET' ) {
       $err_data{set} = read_set_tag(\@lines, $tag);
       $err_data{maQ} = max(max(keys %{$err_data{set}->{1}}), max(keys %{$err_data{set}->{2}}));
    } elsif( $tag eq 'RCH' ) {
        $err_data{rch} = read_rc_tag(\@lines, $tag);
        $err_data{ncyc} = max(max(keys %{$err_data{rch}->{1}}), max(keys %{$err_data{rch}->{2}})) + 1;
    } elsif( $tag eq 'RCL' ) {
        $err_data{rcl} = read_rc_tag(\@lines, $tag);
    } elsif( $tag eq 'PRCNH' ) {
        $err_data{prcnh}= read_win_tag(\@lines, $tag);
    } elsif( $tag eq 'PRCNL' ) {
        $err_data{prcnl}= read_win_tag(\@lines, $tag);
    } else {
      die "Unknown tag $tag\n";
    }
  }

  return \%err_data;
}

# read set tag
sub read_set_tag() {
  my ($lines, $tag) = @_;

  die "Error: reading tag $tag as a SET tag\n" unless $tag =~ m/^SET$/;

  my %set = ();

  foreach my $line (@{$lines}) {
    next unless $line =~ m/^$tag/;

    my @fields = split(/\s+/, $line);
    my ($ctag, $read, $qual) = splice(@fields, 0, 3);
    my %counts = @fields;

    $set{$read}->{$qual}=\%counts;
  }

  return \%set;
}

# read rc tag
sub read_rc_tag() {
  my ($lines, $tag) = @_;

  die "Error: reading tag $tag as a RC tag\n" unless $tag =~ m/^RC[HL]$/;

  my %rc= ();

  foreach my $line (@{$lines}) {
    next unless $line =~ m/^$tag/;

    my @fields = split(/\s+/, $line);
    my ($ctag, $read, $cycle) = splice(@fields, 0, 3);
    my %counts = @fields;

    $rc{$read}->{$cycle}=\%counts;
  }

  return \%rc;
}

# read win tag
sub read_win_tag() {
  my ($lines, $tag) = @_;

  die "Error: reading tag $tag as a WIN tag\n" unless $tag =~ m/^PRCN[HL]$/;

  my %win= ();

  foreach my $line (@{$lines}) {
    next unless $line =~ m/^$tag/;

    my @fields = split(/\s+/, $line);
    my ($ctag, $read) = splice(@fields, 0, 2);
    my %counts = @fields;

    $win{$read}=\%counts;
  }

  return \%win;
}

#%======================================================to process winRi structures
#function [new_win]=stripped_convert_new(win_R1)
#%coverts win_R1 (as in error quality) into converient format, new_win,
#%where each of 12 columns are counts of windows X.Y for each of 12 substitutions
#
#%INPUT input win_R1 (16x12) from error file  see below:
#
#%# Effect of previous base and next base high predictor. Use `grep ^PNCRH | cut -f 2-` to extract this part
#%# 16 rows: one row per pair= previous/next base, columns (12 for each subs) is previous base+substitution+next base and count for 12 substitutions
#
#%PCRNH	1  caA bw AX	AACA	6	AACC	10	AACG	6	AACT	2	AAGA	159	AAGC	125	AAGG	133	AAGT	102	AATA	45	AATC	51	AATG	52	AATT	65
#%PCRNH	1  caC	        ACAA	11	ACAC	23	ACAG	10	ACAT	12	ACGA	2	ACGC	12	ACGG	8	ACGT	4	ACTA	129	ACTC	156	ACTG	276	ACTT	74
#%PCRNH	1  caG	        AGAA	51	AGAC	179	AGAG	77	AGAT	53	AGCA	45	AGCC	32	AGCG	20	AGCT	13	AGTA	646	AGTC	701	AGTG	398	AGTT	209
#%PCRNH	1  caT	        ATAA	49	ATAC	64	ATAG	49	ATAT	53	ATCA	116	ATCC	92	ATCG	137	ATCT	119	ATGA	2	ATGC	7	ATGG	8	ATGT	5
#
#%PCRNH	1  caA bw CX	CACA	6	CACC	4	CACG	14	CACT	12	CAGA	146	CAGC	65	CAGG	155	CAGT	124	CATA	60	CATC	39	CATG	60	CATT	72
#%PCRNH	1	CCAA	56	CCAC	25	CCAG	22	CCAT	30	CCGA	13	CCGC	3	CCGG	7	CCGT	7	CCTA	175	CCTC	34	CCTG	138	CCTT	66
#%PCRNH	1	CGAA	129	CGAC	363	CGAG	97	CGAT	244	CGCA	33	CGCC	37	CGCG	36	CGCT	22	CGTA	463	CGTC	509	CGTG	306	CGTT	251
#%PCRNH	1	CTAA	23	CTAC	46	CTAG	37	CTAT	45	CTCA	178	CTCC	118	CTCG	204	CTCT	202	CTGA	3	CTGC	2	CTGG	9	CTGT	10
#
#%PCRNH	1  caA bw GX	GACA	3	GACC	7	GACG	6	GACT	4	GAGA	99	GAGC	78	GAGG	94	GAGT	83	GATA	60	GATC	58	GATG	46	GATT	72
#%PCRNH	1	GCAA	97	GCAC	20	GCAG	20	GCAT	29	GCGA	11	GCGC	11	GCGG	10	GCGT	14	GCTA	201	GCTC	192	GCTG	307	GCTT	162
#%PCRNH	1	GGAA	53	GGAC	214	GGAG	36	GGAT	94	GGCA	33	GGCC	21	GGCG	7	GGCT	13	GGTA	348	GGTC	388	GGTG	145	GGTT	184
#%PCRNH	1	GTAA	26	GTAC	47	GTAG	33	GTAT	51	GTCA	3520	GTCC	96	GTCG	71	GTCT	104	GTGA	4	GTGC	5	GTGG	11	GTGT	22
#
#%PCRNH	1 caA bw TX	TACA	4	TACC	3	TACG	2	TACT	3	TAGA	96	TAGC	4020	TAGG	209	TAGT	90	TATA	63	TATC	46	TATG	16	TATT	49
#%PCRNH	1	TCAA	28	TCAC	11	TCAG	19	TCAT	23	TCGA	15	TCGC	5	TCGG	7	TCGT	5	TCTA	186	TCTC	65	TCTG	141	TCTT	84
#%PCRNH	1	TGAA	134	TGAC	272	TGAG	112	TGAT	86	TGCA	74	TGCC	47	TGCG	46	TGCT	14	TGTA	774	TGTC	822	TGTG	512	TGTT	211
#%PCRNH	1	TTAA	45	TTAC	63	TTAG	31	TTAT	43
#
#new_win=[];
#N=4;
#
#a=1;
#for f=1:3,
# for k=1:4,
#      j=a+(k-1)*N;
#      for t1=1:4,
#            new_win(j+t1-a,f)=win_R1(j,t1+(f-1)*N); 
#      end
#  end
#end 
#
#
#c=2;
#for f=1:3,
#  for k=1:4,
#      j=c+(k-1)*N;
#      for t1=1:4,
#            new_win(j+t1-c,f+2*c-1)=win_R1(j,t1+(f-1)*N); 
#      end
#  end
#end 
#
#g=3;
#for f=1:3,
#   for k=1:4,
#      j=g+(k-1)*N;
#      for t=1:4,
#            new_win(j+t-g,f+2*g)=win_R1(j,t+(f-1)*N);
#      end
#   end
#end 
#
#
#t=4;
#for f=1:3,
#     for k=1:4,
#      j=t+(k-1)*N;% caG  3,
#      for t1=1:4,
#            new_win(j+t1-t,f+2*t+1)=win_R1(j,t1+(f-1)*N); 
#      end
#  end
#end
#endfunction
#

# generate metrics
sub metrics_gen_assym_prediction () {
  my ($err_data, $verbose) = @_;

  # for now, hard code thresholds
  my $thr_ass = 1; # strand assymetry
  my $thr_art = 0.8;
  my $thr_cv = 0.1;

  my %results = (
    likelihood => -1,
    predict    => -1,
    art_ox     => -1,
    cvTi       => -1,
    symm_ct_ga => -1,
    symm_ag_tc => -1,
    TiTv       => -1,
    TiTv_meGT  => -1,
    bias_ox    => -1,
    symm_gt_ca => -1,
    GT_meTi    => -1,
    gt_nearTi  => -1,
    fracHall   => -1
  );

  my @ti = qw(AG CT GA TC);
  my @tv = qw(AC AT CA CG GC GT TA TG);

  # we only require the read summaries (cycle=-1), make local copies as we may modify them later 
  my %coH1 = %{$err_data->{rch}->{1}->{-1}};
  my %coH2 = %{$err_data->{rch}->{2}->{-1}};
  my %coL1 = %{$err_data->{rcl}->{1}->{-1}};
  my %coL2 = %{$err_data->{rcl}->{2}->{-1}};

  unless (%coH1 && %coH2) {
    return \%results;
  }

  #1----------------------Ti variability and symmetry

  #1.1---------------------------Ti symmetry

  #1.1.1 ---assymetry(sh be symmetry)mis =min separated pair Ti: AG TC
  my $mis1 = min(($coH1{AG}, $coH1{TC}));
  my $mis2 = min(($coH2{AG}, $coH2{TC}));

  #----------------as= asymetry of 'separated' Ti
  my $as_ag_tc_R1 = abs($coH1{AG} - $coH1{TC}) / $mis1;
  my $as_ag_tc_R2 = abs($coH2{AG} - $coH2{TC}) / $mis2;
  my $symm_ag_tc = max(($as_ag_tc_R1, $as_ag_tc_R2));

  #1.1.1.1--------remove strong assymetry if needed (re-define %separated pair
  if ($as_ag_tc_R1 > $thr_ass) {
    $coH1{AG} = $mis1;
    $coH1{TC} = $mis1;
  }
  if ($as_ag_tc_R2 > $thr_ass) {
    $coH2{AG} = $mis2;
    $coH2{TC} = $mis2;
  }

  #1.1.2 ---- strand assymetry (sh be symmetry) mic=min 'close' Ti: CT GA
  my $mic1 = min(($coH1{CT}, $coH1{GA}));
  my $mic2 = min(($coH2{CT}, $coH2{GA}));
  my $as_ct_ga_R1 = abs($coH1{CT} - $coH1{GA}) / $mic1;
  my $as_ct_ga_R2 = abs($coH2{CT} - $coH2{GA}) / $mic2;
  my $symm_ct_ga = max(($as_ct_ga_R1, $as_ct_ga_R2));

  #1.1.2.1-remove close Ti starnd assymetry if needed
  if ($as_ct_ga_R1 > $thr_ass) {
      $coH1{CT} = $mic1;
      $coH1{GA} = $mic1;
  }
  if ($as_ct_ga_R2 > $thr_ass) {
      $coH2{CT} = $mic2;
      $coH2{GA} = $mic2;
  }

  my @ti1 = ($coH1{AG}, $coH1{TC}, $coH1{CT}, $coH1{GA});
  my $mean_ti1 = round(mean(@ti1));
  my $sd_ti1 = round(stddev(@ti1));

  my @ti2 = ($coH2{AG}, $coH2{TC}, $coH2{CT}, $coH2{GA});
  my $mean_ti2 = round(mean(@ti2));
  my $sd_ti2 = round(stddev(@ti2));

  #-----------------cvTi
  my $cvTi1 = $sd_ti1 / $mean_ti1;
  my $cvTi2 = $sd_ti2 / $mean_ti2;
  my $cvTi = max(($cvTi1, $cvTi2));

  my ($Ti1, $Ti2, $Tv1, $Tv2) = (0, 0, 0, 0);
  map {$Ti1 += $coH1{$_}} @ti;
  map {$Ti2 += $coH2{$_}} @ti;
  map {$Tv1 += $coH1{$_}} @tv;
  map {$Tv2 += $coH2{$_}} @tv;

  my $TiTv1 = ($Tv1 > 0 ? ($Ti1 / $Tv1) : 0);
  my $TiTv2 = ($Tv2 > 0 ? ($Ti2 / $Tv2) : 0);
  my $TiTv = max(($TiTv1, $TiTv2));

  #2.2-======------------------TiTv with mddean GT CA across other Tv

  my %coH11 = %coH1;
  my %coH22 = %coH2;

  #------------------actually, CA and GT sh be as other Ti= mean of them
  my @other_Tv1 = ($coH11{AC}, $coH11{AT}, $coH11{CG}, $coH11{GC}, $coH11{TA}, $coH11{TG});
  my $meTv1 = mean(@other_Tv1);
  $coH11{CA} = $meTv1;
  $coH11{GT} = $meTv1;
  my @other_Tv2 = ($coH22{AC}, $coH22{AT}, $coH22{CG}, $coH22{GC}, $coH22{TA}, $coH22{TG});
  my $meTv2 = mean(@other_Tv2);
  $coH22{CA} = $meTv2;
  $coH22{GT} = $meTv2;

  my ($si1, $si2, $sv1, $sv2) = (0, 0, 0, 0);
  map {$si1 += $coH11{$_}} @ti;
  map {$si2 += $coH22{$_}} @ti;
  map {$sv1 += $coH11{$_}} @tv;
  map {$sv2 += $coH22{$_}} @tv;

  my $si_sv1 = ($sv1 > 0 ? ($si1 / $sv1) : 0);
  my $si_sv2 = ($sv2 > 0 ? ($si2 / $sv2) : 0);
  my $TiTv_meGT = max(($si_sv1, $si_sv2));

  #3========metrics on oxiG and GT/CA artefact
  #artefact C2A=art_ox=proportion of gt/ca to mean Ti, depends
  #on Ti variability 
  my $thr_ti1 = $mean_ti1 - ($cvTi1 > $thr_cv ? 1 : 3) * $sd_ti1;
  my $thr_ti2 = $mean_ti2 - ($cvTi2 > $thr_cv ? 1 : 3) * $sd_ti2;

  #===============art_ox=proportion of gt or ca to mean Ti
  my $ma1 = max(($coH1{CA}, $coH1{GT}));
  my $ma2 = max(($coH2{CA}, $coH2{GT}));

  # prop max(gt,ca) in Ti: the higher the more likely artC2A
  my $artR1 = $ma1 / $thr_ti1;
  my $artR2 = $ma2 / $thr_ti2;
  my $art_ox = max(($artR1, $artR2));

  #3.2 ----------------------oxidation biasas BROAD
  #BROAD found CCG->CAG and GT more at R1, CA more at R2
  my ($bR1, $bR2) = (-1, -1);
  if ($coH1{CA} > 0 && $coH2{GT} > 0) {
    $bR1 = abs(($coH1{GT} - $coH1{CA}) / $coH1{CA}); # divided by expected smaller- check the paper
    $bR2 = abs(($coH2{GT} - $coH2{CA}) / $coH2{GT}); # divided by expected smaller- check the paper
  }
  my $bias_ox = max(($bR1, $bR2));

  #3.3-----------GT assymmetry
  #here we look at strand assymetry (sh be symmetry), in contrast to BROAD
  my $mi1 = min(($coH1{CA}, $coH1{GT}));
  my $mi2 = min(($coH2{CA}, $coH2{GT}));

  my ($b1, $b2) = (-1, -1);
  if ($mi1 > 0 && $mi2 > 0) {
    $b1 = abs($coH1{GT} - $coH1{CA}) / $mi1; # divided by smaller- not as in the paper
    $b2 = abs($coH2{GT} - $coH2{CA}) / $mi2;
  }
  my $symm_gt_ca = max(($b1, $b2));

  #3.4---------GT/TC relation to TC (the closest Ti) OR CA to AG

  my $gt_tc_1 = $coH1{GT} / $coH1{TC};
  my $gt_tc_2 = $coH2{GT} / $coH2{TC};
  my $ca_ag_1 = $coH1{CA} / $coH1{AG};
  my $ca_ag_2 = $coH2{CA} / $coH2{AG};

  my $gt_nearTi = max((max(($gt_tc_1,$ca_ag_1)),max(($gt_tc_2,$ca_ag_2))));

  #3.5---------------------GT to meanTi
  my $GT_meTi1 =  $coH1{GT} / $mean_ti1;
  my $GT_meTi2 =  $coH2{GT} / $mean_ti2;
  my $GT_meTi = max(($GT_meTi1, $GT_meTi2));

  #4=======----------fracHall
  my $fracHL1 = sum(values %coH1) / (sum(values %coL1) + sum(values %coH1));
  my $fracHL2 = sum(values %coH2) / (sum(values %coL2) + sum(values %coH2));
  my $fracH = round(100.0 * max(($fracHL1, $fracHL2)));

  my $fracHL1a = sum(values %coH1) / (sum(values %coL1) + sum(values %coH1) + sum(values %coL2) + sum(values %coH2));
  my $fracHL2a = sum(values %coH2) / (sum(values %coL1) + sum(values %coH1) + sum(values %coL2) + sum(values %coH2));
  my $fracHall = max(($fracHL1a, $fracHL2a));

  #5---------------predictions and prolly based on likelihood of art-ox
  my $pred_high = 3;
  my $pred_med = 2;
  my $pred_low = 1;
  my $pred_no = 0;

  my $predict = -1;

  if ($art_ox >= $thr_art) {
     if ($verbose) {
       printf("likely C2A artefact %s\n", $art_ox);
     }
     $predict = predict_artefactOx_const($thr_art, $art_ox, $pred_low, $pred_med, $pred_high);
  } else {
     if ($verbose) {
       printf("not likely C2A artefact\n");
     }
     $predict = $pred_no;
  }

  #5.2--------compute probability/likelihood of C2A based on art_ox
  my $likely = 0.25 * ($artR1 + $artR2);
  my $new_likely = $likely;
  if ($likely > 1) {
    $new_likely = 1;
  }
  my $likelihood = $new_likely;

  # update results
  $results{likelihood} = $likelihood;
  $results{predict}    = $predict;
  $results{art_ox}     = $art_ox;
  $results{cvTi}       = $cvTi;
  $results{symm_ct_ga} = $symm_ct_ga;
  $results{symm_ag_tc} = $symm_ag_tc;
  $results{TiTv}       = $TiTv;
  $results{TiTv_meGT}  = $TiTv_meGT;
  $results{bias_ox}    = $bias_ox;
  $results{symm_gt_ca} = $symm_gt_ca;
  $results{GT_meTi}    = $GT_meTi;
  $results{gt_nearTi}  = $gt_nearTi;
  $results{fracHall}   = $fracHall;

  return \%results;
}

# predictor
sub predict_artefactOx_const() {
  my ($thr, $art_ox, $pred_low, $pred_med, $pred_high) = @_;

  my $predict = -1;

  my $thrM = $thr + 0.2;
  my $thrH = $thr + 0.6;

  if ($art_ox > $thrH) {
    $predict = $pred_high;
  } elsif($art_ox >= $thrM) {
    $predict = $pred_med;
  } elsif($art_ox >= $thr) {
    $predict = $pred_low;
  }

  return $predict;
}

# write_metrics_file
sub write_metrics_file () {
  my ($metrics, $file) = @_;

  my $level = -1;

  open FILE, ">$file" or die "Can't open $file : $!\n";

  printf FILE "#C2A related stats and metrics for a tag\n"; 
  printf FILE "TiTv_class %.2f\n", $metrics->{TiTv};
  printf FILE "TiTv_meCA %.2f\n",  $metrics->{TiTv_meGT};
  printf FILE "fracH %.2f\n",      $metrics->{fracHall};
  printf FILE "oxoGHbias %.2f\n",  $metrics->{bias_ox};
  printf FILE "symGT_CA %.2f\n",   $metrics->{symm_gt_ca};
  printf FILE "sym_ct_ga %.2f\n",  $metrics->{symm_ct_ga};
  printf FILE "sym_ag_tc %.2f\n",  $metrics->{symm_ag_tc};
  printf FILE "cvTi %.2f\n",       $metrics->{cvTi};
  printf FILE "GT_Ti %.2f\n",      $metrics->{gt_nearTi};
  printf FILE "GT_meTi %.2f\n",    $metrics->{GT_meTi};
  printf FILE "level %d\n",        $level;
  printf FILE "art_oxH %.2f\n",    $metrics->{art_ox};
  printf FILE "predict %d\n",      $metrics->{predict};

  close FILE;

  return;
}

=head1 CONFIGURATION

=head1 SYNOPSIS

=head1 DESCRIPTION

=head1 SUBROUTINES/METHODS

=head1 DIAGNOSTICS

=head1 CONFIGURATION AND ENVIRONMENT

=head1 REQUIRED ARGUMENTS

=head1 OPTIONS

=head1 EXIT STATUS

=head1 DEPENDENCIES

=over

=item strict

=item warnings

=item FindBin

=item Getopt::Long

=item File::Slurp

=item FileHandle

=item Math::Round

=item Statistics::Lite

=back

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

=head1 AUTHOR

Irina Abnizova<lt>ia1@sanger.ac.ukE<gt>

Steven Leonard<lt>srl@sanger.ac.ukE<gt>

=head1 LICENSE AND COPYRIGHT

Copyright (C) 2011 GRL, by Irina Abnizova & Steven Leonard

This file is part of NPG.

NPG is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

